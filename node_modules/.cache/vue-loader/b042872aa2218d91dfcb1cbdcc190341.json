{"remainingRequest":"/Users/mttest/Profile/mac-drive-web/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/mttest/Profile/mac-drive-web/src/views/components/FileUploader.vue?vue&type=style&index=0&id=5489284e&lang=stylus&scoped=true&","dependencies":[{"path":"/Users/mttest/Profile/mac-drive-web/src/views/components/FileUploader.vue","mtime":1701827905864},{"path":"/Users/mttest/Profile/mac-drive-web/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/mttest/Profile/mac-drive-web/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/Users/mttest/Profile/mac-drive-web/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/Users/mttest/Profile/mac-drive-web/node_modules/stylus-loader/index.js","mtime":1519606876000},{"path":"/Users/mttest/Profile/mac-drive-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/mttest/Profile/mac-drive-web/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgojZ2xvYmFsLXVwbG9hZGVyIHsKICBwb3NpdGlvbjogZml4ZWQ7CiAgei1pbmRleDogMjA7CiAgcmlnaHQ6IDE1cHg7CiAgYm90dG9tOiAxNXB4OwoKICAudXBsb2FkZXItYm94IHsKICAgIHdpZHRoOiA1MjBweDsKICB9CgogIC5maWxlLXBhbmVsIHsKICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7CiAgICBib3JkZXI6IDFweCBzb2xpZCAjZTJlMmUyOwogICAgYm9yZGVyLXJhZGl1czogN3B4IDdweCAwIDA7CiAgICBib3gtc2hhZG93OiAwIDAgMTBweCByZ2JhKDAsIDAsIDAsIDAuMik7CgogICAgLnBhbmVsLXRpdGxlIHsKICAgICAgZGlzcGxheTogZmxleDsKICAgICAgaGVpZ2h0OiA0MHB4OwogICAgICBsaW5lLWhlaWdodDogNDBweDsKICAgICAgcGFkZGluZzogMCAxNnB4OwogICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2RkZDsKCiAgICAgIC50ZXh0IHsKICAgICAgICBwYWRkaW5nLWxlZnQ6IDA7CiAgICAgICAgbWFyZ2luLWJvdHRvbTogMDsKICAgICAgICBmb250LXNpemU6IDE2cHg7CiAgICAgICAgY29sb3I6ICMzMDMxMzM7CiAgICAgIH0KCiAgICAgIC5vcGVyYXRlLWJ0bi13cmFwcGVyIHsKICAgICAgICBmbGV4OiAxOwogICAgICAgIHRleHQtYWxpZ246IHJpZ2h0OwoKICAgICAgICA+Pj4gLmVsLWJ1dHRvbiB7CiAgICAgICAgICAqOmhvdmVyIHsKICAgICAgICAgICAgb3BhY2l0eTogMC41OwogICAgICAgICAgfQoKICAgICAgICAgIGlbY2xhc3NePWVsLWljb24tXSB7CiAgICAgICAgICAgIGNvbG9yOiAjMDAwOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfQoKICAgIC5maWxlLWxpc3QgewogICAgICBwb3NpdGlvbjogcmVsYXRpdmU7CiAgICAgIGhlaWdodDogMjQwcHg7CiAgICAgIG92ZXJmbG93LXg6IGhpZGRlbjsKICAgICAgb3ZlcmZsb3cteTogYXV0bzsKICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjsKICAgICAgZm9udC1zaXplOiAxNHB4OwoKICAgICAgLmZpbGUtaXRlbSB7CiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjsKCiAgICAgICAgPj4+LnVwbG9hZGVyLWZpbGUtaWNvbiB7CiAgICAgICAgICBkaXNwbGF5OiBub25lOwogICAgICAgIH0KICAgICAgfQogICAgfQogIH0KCiAgLm5vLWZpbGUgewogICAgcG9zaXRpb246IGFic29sdXRlOwogICAgdG9wOiA1MCU7CiAgICBsZWZ0OiA1MCU7CiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTsKICAgIGZvbnQtc2l6ZTogMTZweDsKICB9CgogIC9kZWVwLy51cGxvYWRlci1maWxlLWFjdGlvbnMgPiBzcGFuIHsKICAgIG1hcmdpbi1yaWdodDogNnB4OwogIH0KfQoKLyog6ZqQ6JeP5LiK5Lyg5oyJ6ZKuICovCi5zZWxlY3QtZmlsZS1idG4gewogIGRpc3BsYXk6IG5vbmU7Cn0K"},{"version":3,"sources":["FileUploader.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgRA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"FileUploader.vue","sourceRoot":"src/views/components","sourcesContent":["<template>\n  <div id=\"global-uploader\">\n    <!-- 上传组件 -->\n    <uploader\n      class=\"uploader-box\"\n      ref=\"uploader\"\n      :options=\"options\"\n      :autoStart=\"false\"\n      @file-added=\"handleFileAdded\"\n      @file-progress=\"onFileProgress\"\n      @file-success=\"handleFileSuccess\"\n      @file-error=\"handleFileError\"\n    >\n      <uploader-unsupport></uploader-unsupport>\n      <!-- 选择文件按钮 -->\n      <uploader-btn class=\"select-file-btn\" :attrs=\"attrs\" ref=\"uploadBtn\"\n        >选择文件</uploader-btn\n      >\n      <!-- 正在上传的文件面板 -->\n      <uploader-list v-show=\"panelShow\">\n        <div class=\"file-panel\" slot-scope=\"props\">\n          <div class=\"panel-title\">\n            <span class=\"text\">上传列表</span>\n            <div class=\"operate-btn-wrapper\">\n              <el-button\n                type=\"text\"\n                title=\"关闭窗口\"\n                icon=\"el-icon-close\"\n                @click=\"handleClosePanel\"\n              >\n              </el-button>\n            </div>\n          </div>\n          <!-- 正在上传的文件列表 -->\n          <ul class=\"file-list\">\n            <li class=\"file-item\" v-for=\"file in props.fileList\" :key=\"file.id\">\n              <uploader-file\n                ref=\"files\"\n                :class=\"`file_${file.id}`\"\n                :file=\"file\"\n                :list=\"true\"\n              ></uploader-file>\n            </li>\n            <div class=\"no-file\" v-if=\"!props.fileList.length\">\n              <i class=\"icon-empty-file\"></i> 暂无待上传文件\n            </div>\n          </ul>\n        </div>\n      </uploader-list>\n    </uploader>\n  </div>\n</template>\n\n<script>\nimport SparkMD5 from \"spark-md5\";\nimport { getMultipartUpload, getUpFile } from \"@/request/file\";\n\nexport default {\n  name: \"FileUploader\",\n  data() {\n    return {\n      options: {\n        // 目标上传 URL，可以是字符串也可以是函数，如果是函数的话，则会传入 Uploader.File 实例、\n        // 当前块 Uploader.Chunk 以及是否是测试模式，默认值为 '/'\n        target: function(file, chunkFile, mode) {\n          // 分块上传前每次都会进入到该方法\n          console.log(\"进入到target\");\n          console.log(\"文件名：\" + file.name);\n          console.log(\"当前分块序号\" + chunkFile.offset);\n          console.log(\"获取到分块上传URL：\");\n          console.log(file.chunkUrlData);\n          const key = \"chunk_\" + chunkFile.offset; // 键值 用于获取分块链接URL\n          return file.chunkUrlData[key];\n        },\n        // 为每个块向服务器发出 GET 请求，以查看它是否已经存在。如果在服务器端实现，\n        // 这将允许在浏览器崩溃甚至计算机重新启动后继续上传。(默认: true)\n        testChunks: true,\n        // 分块时按照该值来分。最后一个上传块的大小是可能是大于等于1倍的这个值但是小于两倍的这个值大小，\n        // 可见这个 Issue #51，默认 1*1024*1024。\n        chunkSize: 5 * 1024 * 1024,\n        // 强制所有块小于或等于 chunkSize。否则，最后一个块将大于或等于chunkSize。(默认: false)\n        forceChunkSize: true,\n        // 包含在带有数据的多部分 POST 中的额外参数。这可以是一个对象或一个函数。如果是一个函数，\n        // 它将被传递一个 Uploader.File、一个 Uploader.Chunk 对象和一个 isTest 布尔值（默认值{}：）\n        query: function(file, chunkFile, mode) {\n          const data = { partNumber: chunkFile.offset + 1 };\n          return data;\n        },\n        uploadMethod: \"PUT\",\n        //  当上传的时候所使用的是方式，可选 multipart、octet，默认 multipart，参考 multipart vs octet。\n        // MiniO 的分片不能使用表单\n        method: \"octet\",\n        //  处理请求参数，默认 function (params) {return params}，一般用于修改参数名字或者删除参数。0.5.2版本后，\n        processParams: function(params) {\n          return {};\n        }\n        // headers: {\n        //  'Content-Type': 'binary/octet-stream'\n        // }\n      },\n      attrs: {\n        accept: \"*\" // 可接受的文件类型\n      },\n      panelShow: false //  上传文件面板是否显示\n    };\n  },\n  computed: {\n    // 全局上传组件 uploader实例\n    uploader() {\n      return this.$refs.uploader.uploader;\n    },\n    // 当前所在路径\n    filePath() {\n      return this.$route.query.filePath ? this.$route.query.filePath : \"/\";\n    },\n    // 是否触发上传文件事件\n    startUploadFile() {\n      return this.$store.state.file.startUploadFile;\n    }\n  },\n  methods: {\n    // 触发选择文件按钮的点击事件\n    triggerSelectFileClick() {\n      this.$refs.uploadBtn.$el.click(); // 触发 选择文件按钮 的点击事件\n    },\n\n    // 文件添加 回调函数\n    handleFileAdded(file) {\n      this.panelShow = true; //  显示文件上传面板\n      this.calculateFileMD5(file); //  计算文件MD5值\n      // 计算MD5\n      // 获取分块上传链接\n      // eslint-disable-next-line no-unused-vars\n      const res = this.getChunkUploadUrl(file);\n      console.log(\"文件被添加查看是否获取到分块URL\");\n      console.log(file.chunkUrlData);\n    },\n    async getChunkUploadUrl(file) {\n      // 向具有指定ID的用户发出请求\n      console.log(file);\n      console.log(\"获取分块上传链接\");\n      const fileName = file.name; // 文件名\n      const fileSize = file.size; // 文件大小\n      const chunkSize = file.chunks.length; // 分片数\n      // const  file\n      // 请求后台返回每个分块的上传链接\n      // eslint-disable-next-line no-unused-vars\n      const res = await getUpFile({\n        filename: fileName,\n        chunkNumber: chunkSize,\n        filePath: this.filePath,\n        uploadTime: new Date().getTime(),\n        fileSize: fileSize,\n        identifier: file.uniqueIdentifier\n      })\n        .then(function(response) {\n          console.log(\"获取到的uploadId:\" + response.uploadId);\n          console.log(\"获取到的分片上传集合URL:\");\n          file.chunkUrlData = response;\n          console.log(file.chunkUrlData);\n        })\n        .catch(function(error) {\n          console.log(error);\n        });\n    },\n    /**\n     * 文件上传过程 回调函数\n     * @param rootFile 成功上传的文件所属的根 Uploader.File 对象，它应该包含或者等于成功上传文件\n     * @param file 当前成功的 Uploader.File 对象本身\n     * @param chunk Uploader.Chunk 实例，它就是该文件的最后一个块实例，如果你想得到请求响应码的话，chunk.xhr.status 就是\n     */\n    onFileProgress(rootFile, file, chunk) {\n      // 打印文件上传过程中的信息\n      console.log(\n        `上传中 ${file.name}，chunk：${chunk.startByte /\n          1024 /\n          1024} ~ ${chunk.endByte / 1024 / 1024}`\n      );\n    },\n    /**\n     * 文件上传成功 回调函数\n     * @param rootFile\n     * @param file\n     */\n    handleFileSuccess(rootFile, file) {\n      console.log(\"单个文件上传成功\", arguments);\n      // 调用后台合并文件\n      const fileName = file.name; // 文件名\n      const uploadId = file.chunkUrlData.uploadId; // uploadId\n      console.log();\n      getMultipartUpload({\n        FileName: fileName,\n        uploadId: uploadId\n      })\n        .then(function(response) {\n          console.log(response);\n        })\n        .catch(function(error) {\n          console.log(error);\n        });\n      console.log(\"合并完成\");\n      this.$emit(\"getTableData\"); //  刷新文件列表\n    },\n\n    // 文件上传失败 回调函数\n    handleFileError(rootFile, file, responseStr) {\n      this.$message({\n        message: JSON.parse(responseStr).message,\n        type: \"error\"\n      });\n    },\n\n    // 计算文件MD5值\n    calculateFileMD5(file) {\n      let fileReader = new FileReader();\n      let blobSlice =\n        File.prototype.slice ||\n        File.prototype.mozSlice ||\n        File.prototype.webkitSlice;\n      let currentChunk = 0;\n      const chunkSize = 5 * 1024 * 1024;\n      let chunks = Math.ceil(file.size / chunkSize);\n      let spark = new SparkMD5.ArrayBuffer();\n      file.pause(); //  暂停上传文件\n      loadNext();\n      fileReader.onload = e => {\n        spark.append(e.target.result);\n        if (currentChunk < chunks) {\n          currentChunk++;\n          loadNext();\n        } else {\n          let md5 = spark.end();\n          this.calculateFileMD5End(md5, file);\n          // console.log(\n          //   `MD5计算完毕：${file.name} \\nMD5：${md5} \\n分片：${chunks} 大小:${\n          //     file.size\n          //   } 用时：${new Date().getTime() - time} ms`\n          // );\n        }\n      };\n      fileReader.onerror = function() {\n        this.$notify({\n          title: \"上传出错\",\n          message: `文件${file.name}读取出错，请检查该文件`,\n          type: \"error\",\n          duration: 2000\n        });\n        file.cancel(); //  取消上传且从文件列表中移除。\n      };\n      function loadNext() {\n        let start = currentChunk * chunkSize;\n        let end =\n          start + chunkSize >= file.size ? file.size : start + chunkSize;\n        fileReader.readAsArrayBuffer(blobSlice.call(file.file, start, end));\n      }\n    },\n    // 文件MD5计算结束\n    calculateFileMD5End(md5, file) {\n      file.uniqueIdentifier = md5;\n      file.resume(); //  继续上传文件\n    },\n\n    // 关闭上传面板\n    handleClosePanel() {\n      this.uploader.cancel(); //  取消上传文件\n      this.panelShow = false;\n    }\n  }\n};\n</script>\n\n<style lang=\"stylus\" scoped>\n#global-uploader {\n  position: fixed;\n  z-index: 20;\n  right: 15px;\n  bottom: 15px;\n\n  .uploader-box {\n    width: 520px;\n  }\n\n  .file-panel {\n    background-color: #fff;\n    border: 1px solid #e2e2e2;\n    border-radius: 7px 7px 0 0;\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);\n\n    .panel-title {\n      display: flex;\n      height: 40px;\n      line-height: 40px;\n      padding: 0 16px;\n      border-bottom: 1px solid #ddd;\n\n      .text {\n        padding-left: 0;\n        margin-bottom: 0;\n        font-size: 16px;\n        color: #303133;\n      }\n\n      .operate-btn-wrapper {\n        flex: 1;\n        text-align: right;\n\n        >>> .el-button {\n          *:hover {\n            opacity: 0.5;\n          }\n\n          i[class^=el-icon-] {\n            color: #000;\n          }\n        }\n      }\n    }\n\n    .file-list {\n      position: relative;\n      height: 240px;\n      overflow-x: hidden;\n      overflow-y: auto;\n      background-color: #fff;\n      font-size: 14px;\n\n      .file-item {\n        background-color: #fff;\n\n        >>>.uploader-file-icon {\n          display: none;\n        }\n      }\n    }\n  }\n\n  .no-file {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    font-size: 16px;\n  }\n\n  /deep/.uploader-file-actions > span {\n    margin-right: 6px;\n  }\n}\n\n/* 隐藏上传按钮 */\n.select-file-btn {\n  display: none;\n}\n</style>\n"]}]}